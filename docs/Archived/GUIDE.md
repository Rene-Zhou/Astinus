# Astinus 项目开发参考

Astinus（阿斯特纽斯）是一个 AI 驱动的叙事导向的类 ttrpg 游戏，旨在利用 AI multi-agnet 架构，提供
叙事主义（narrativism）的单人ttrpg体验。

## 1. 核心设计原则

| 原则 | 说明 |
|------|------|
| **纯自然语言** | 无选项菜单（A攻击，B逃跑），玩家用自己的话行动，AI 理解意图并推进 |
| **上下文隔离** | 每个 NPC 只知道自己该知道的事，不同的 agent 上下文隔离，由 GM agnet 统筹 |
| **规则透明** | 骰子判定公开，玩家能理解为何成功/失败 |
| **模块化叙事** | 故事包可插拔，引擎与内容分离 |
| **多语言支持** | 前端界面、系统提示与叙事资产必须通过本地化资源加载，至少提供简体中文（cn）与英文（en）版本 |

为了落实多语言原则，所有前端界面文本、系统提示与日志摘要必须通过可扩展的本地化资源表或 i18n 管线加载，禁止直接硬编码在控件或脚本中。世界包、Agent 提示模板以及任意面向玩家的叙事文本都需要为至少 `cn` 与 `en` 提供独立内容，并在缺失翻译时定义合理的回退策略。

## 2. Agent 架构

Astinus 采用**星形（Hub-and-Spoke）** 多智能体架构，以 GM Agent 为中央枢纽，通过上下文隔离实现高效的多智能体协作。这种设计最大化利用 Token 效率，同时防止 NPC 产生信息泄露和幻觉。

### 2.1 全局架构拓扑 GM Agent

**GM Agent 是唯一的"全知者"**，维护完整的游戏全局状态。其他所有 Agent（NPC、规则裁判、剧情导演等）都接收经过"切片"的上下文信息，仅知道它们需要完成的当前任务和必要背景。

#### 全局游戏状态 (GameState)

```python
class GameState:
    messages: list                # 完整的对话历史（仅 GM 可见）
    world_state: dict            # 当前场景、时间、活跃 NPC 列表
    player_profile: dict         # 玩家的特质和标签
    current_phase: str           # 当前阶段（如：Narrating, Waiting_Input）
    next_agent: str              # 路由目标（下一个该谁行动）
    temp_context: str            # 临时传递给子 Agent 的上下文片段
```

### 2.2 各个 Agent 的职责

#### A. GM Agent（指挥官 / 中央大脑）

**角色定位**：中央处理器、路由控制器、上下文过滤器

**核心职责**：
1. **意图识别与路由**：分析玩家输入，判断意图属于规则判定、NPC 互动还是背景查询，路由给对应 Agent
2. **上下文切片**：从全局历史中提取最后 3-5 轮对话，结合当前场景描述，生成精简的 Prompt 传递给子 Agent
3. **结果合成**：接收子 Agent 的输出，转化为统一的叙事风格反馈给玩家
4. **状态更新**：每个回合结束后，更新全局游戏状态

**LangGraph 行为**：作为图的入口节点（Entry Point），根据 `next_agent` 决定状态流向。

#### B. NPC Agent（演员 / 子智能体）

**角色定位**：纯粹的角色扮演者，上下文隔离的有限记忆体

**核心职责**：
- 接收 GM 传来的"人设卡"、"当前情境"和"玩家的话"
- 生成符合人设的对话、表情和动作
- 由于上下文被 GM 过滤，NPC 不知道它"不在场"时发生的事，有效防止 Metagaming

**工作流**：
- 接收 System Prompt（人设）+ Human Message（GM 总结的现状 + 玩家原话）
- 输出纯文本对话或结构化动作（如 `{"action": "angry_shout", "text": "滚出去！"}` ）

#### C. Rule Agent（规则裁判 / 确定性引擎）

**角色定位**：规则执行者，逻辑计算引擎

**核心职责**：
- 处理技能检定、特质/标签的判定和变更
- 调用工具执行确定性代码（`roll_dice()`, `add_tag()` 等），不依赖 LLM 的随机生成

**工作流示例**：
1. GM 识别到"我要翻找这本书寻找线索"的掷骰需求
2. 向玩家发送掷骰请求，包含影响因素和修正信息
3. 玩家掷骰，Rule Agent 接收结果（如 2d6=8）
4. Rule Agent 根据掷骰结果返回结构化反馈，包含成功/部分成功的叙事后果
5. GM 根据反馈描述场景、更新玩家状态标签

#### D. Lore Agent（图书馆员 / 背景检索器）

**角色定位**：世界观和设定信息的检索器

**核心职责**：
- 当玩家询问背景设定或 GM 需要描述新场景时被调用
- 从世界包（World Package）中提取相关文档和设定

#### E. Director Agent（幕后导演 / 可选）

**角色定位**：情节节奏控制器，关注故事的情感弧线

**核心职责**：
- 基于 GNS 理论中的"叙事主义"，监控故事的紧张度和激情度
- 动态调整全局状态参数，不直接生成文本。例如在玩家遇到瓶颈时引入突发危机，或在故事高潮时增加难度修正

### 2.3 工作流示例

假设玩家输入："我拔出剑，愤怒地砍向那个嘲笑我的兽人。"

1. **GM Node（接收）**：分析意图为"攻击"，路由给 Rule Agent
2. **Rule Node（掷骰）**：与玩家一同完成掷骰，得到结果（如 2d6=3 失败）
3. **GM Node（再次决策）**：看到攻击失败，需要 NPC 做出反应，路由给 NPC Agent
4. **NPC Node（执行）**：在"傲慢兽人"的人设约束下，生成回复
5. **GM Node（最终输出）**：合成规则结果和 NPC 回复，输出完整场景描述给玩家

### 2.4 核心优势

- **Token 节省**：子 Agent 每次只处理最小信息量，无需加载完整对话历史
- **一致性**：GM 掌握全局状态，防止 NPC 胡言乱语或剧透
- **模块化**：可为不同 Agent 配置不同的 LLM 模型，实现成本与效果最优配置

## 3. 游戏系统

游戏采用极其简单的2d6系统，没有属性值，没有专长这些元素。通过简单的系统来激发叙事的更大可能。

### 3.1 角色构成

角色构成:
  - 核心概念（一句话来对角色进行描述，例如“失业的建筑师”、“只会炼金术的法师”）
  - 一般而言，初始有 3 个特质 (Traits)
  - 每个特质都有正面和负面
  - 可以在游戏过程中获得新的特质

特质结构:

```
  name: "简短标签"
  description: "完整描述"
  positive_aspect: "这个特质如何帮助角色"
  negative_aspect: "这个特质如何阻碍角色"
```

特质示例：

```
 name: "优柔寡断"
 description: "在行动前总是会思考许多，在脑内预演所能想象到的可能性，在具体执行上往往迟疑不决"
 positive_aspect: "经常能预演各种可能性，从而提前了解到决策可能的后果，从而做出更明智的决策"
 negative_aspect: "常常因为过度思考而错过最佳时机"
```
  
### 3.2 角色状态

不通过诸如 HP 来追踪角色的状态，而是通过一系列标签（tag）来追踪角色，例如角色腿部中了一枪，那
么就给玩家一个<腿部枪伤>的 tag。不同于 trait，tag 是可以纯粹正面/负面的，例如<腿部枪伤>就会
导致玩家在例如逃跑这类的检定中获得劣势。

### 3.3 游戏检定

判定:
  1. 基础骰: 2d6
  
  2. 结果:
  
    - 10+: 强成功（success），也就是完全成功
    - 7-9: 弱成功（partial success），成功但有代价
    - 6-: 失败，故事继续
  
  3. 修正:
  
    - 优势，特质/标签正面相关: +1d6 (取最高的两个骰值，即 `/r3d6kh2`)
    - 劣势，特质/标签负面触发: -1d6 (取最低的两个骰值，即 `/r3d6kl2`)
    - 优劣可以抵消，优劣可以叠加：例如，一个“运动健将”特质+“腿部中枪”标签，可以抵消劣势；“文弱”特质+“腿部中枪”标签，则需要投4个d6,取最低的两个的加值

### 3.4 为什么这样设计

- 无属性值 → 角色创建即讲故事，不是填数字
- 双面特质 → 每个优势都带着劣势，角色更立体
- AI 友好 → 比"敏捷 vs 智力"更容易判断相关性
- 鼓励叙事 → 玩家必须解释特质如何帮助，而不是被动等结果

### 3.5 可能的改进方向

#### 边玩边建卡 (Character Creation on the Fly)

解决的痛点：角色创建时，玩家需要提前规划好所有特质，这可能会导致角色设定过于僵硬，缺乏灵活性，或是
整场游戏中都没有用到某个特质。

游戏开始时，你只填写角色的核心概念（例如“帝国逃兵”），特质留空。

在游戏中填写：当你在游戏中突然灵光一现，或者做了一件非常酷的事情时（例如你成功欺骗了守卫），你可以
当场宣布：“我要把我的第一个特质定为 ‘三寸不烂之舌’！”

## 4. 世界包结构

世界包（World Package）是 Astinus 存储世界观设定的核心数据结构。参考 SillyTavern 的 World Info 设计，我们采用 JSON 格式来组织这些数据，以便 Lore Agent 能够高效地检索和注入上下文。

### 4.1 文件格式

每个世界包是一个独立的 `.json` 文件，包含该世界的元数据和一系列词条（Entries）。

```json
{
  "info": {
    "name": {
      "cn": "艾泽拉斯",
      "en": "Azeroth"
    },
    "description": {
      "cn": "一个充满魔法、冲突与冒险的高奇幻世界。",
      "en": "A high fantasy world filled with magic, conflict, and adventure."
    },
    "version": "1.0.0",
    "author": "Astinus Team"
  },
  "entries": {
    "1": {
      "uid": 1,
      "key": ["暴风城", "Stormwind"],
      "secondary_keys": ["联盟", "Alliance"],
      "comment": {
        "cn": "人类的主要聚集地",
        "en": "Primary gathering place for humans."
      },
      "content": {
        "cn": "暴风城是艾泽拉斯人类王国的最后堡垒，位于艾尔文森林的西北部。它是一座宏伟的城市，由坚固的石墙保护，是联盟的政治和军事中心。",
        "en": "Stormwind is the last bastion of the human kingdoms in Azeroth, located in the northwest of Elwynn Forest. Enclosed by sturdy stone walls, it serves as the political and military center of the Alliance."
      },
      "constant": false,
      "selective": true,
      "order": 100
    }
  }
}
```

### 4.2 词条属性详解

| 属性 | 类型 | 说明 |
|------|------|------|
| **uid** | Integer | 词条的唯一标识符。 |
| **key** | Array[String] | **触发关键词**。当玩家输入或当前上下文中出现这些词时，Lore Agent 会考虑提取此词条。 |
| **secondary_keys** | Array[String] | **辅助关键词**。如果设置，仅当主关键词存在且辅助关键词也存在时，才会触发（逻辑 AND）。 |
| **content** | Dict[String, String] | **设定内容**。以语言代码为键的内容映射，至少包含 `cn` 与 `en`。在缺失语言时需定义回退策略，避免玩家看到错误语言。 |
| **comment** | Dict[String, String] 或 String | **备注**。仅供编辑者查看的说明，可以存储多语言文本，默认不发送给 AI。 |
| **constant** | Boolean | **常驻**。如果为 `true`，该词条将始终存在于上下文中，不依赖关键词触发（慎用，以免占用过多 Token）。 |
| **selective** | Boolean | **选择性触发**。通常为 `true`，表示仅在触发时加载。 |
| **order** | Integer | **插入顺序**。决定词条在 Prompt 中的排列顺序，数值越小越靠前。 |

### 4.3 Lore Agent 的检索策略

Lore Agent 在 Demo 阶段仅进行简单的关键词匹配。向量检索（Vector Search）作为未来规划。

1. **关键词匹配**：首先扫描玩家输入和最近对话，匹配 `key` 和 `secondary_keys`。
2. **语义检索 [暂不开发]**：将 `content` 预先向量化。当 GM Agent 提出查询请求时（例如“查询关于这个纹章的历史”），Lore Agent 计算查询向量与词条向量的相似度。这对于 Demo 而言工程量过大，暂不实现。
3. **上下文注入**：将匹配到的词条 `content` 组合，作为背景信息传递给 GM Agent 或 NPC Agent。

这种结构确保了即使面对庞大的世界观设定，Agent 也能保持轻量级运行，仅在需要时获取相关知识。

## 5. NPC 构成

NPC 是 Astinus 中的关键智能体。在 Agent 架构下，NPC 不仅是被动的聊天机器人，而是具有自主性、记忆和状态的游戏实体。本章定义了如何构建一个既能自然对话又能参与游戏逻辑的 NPC。

### 5.1 双层定义法：叙事层 + 数据层

NPC 由两个独立的层次组成，分别负责"怎么说话"和"能做什么"。

#### A. 叙事层（The Soul）—— 角色人设

这部分被注入到 LLM 的 System Prompt，决定 NPC 的说话风格和性格表现。

**包含字段**：
- **Name（名字）**：NPC 的标识符
- **Description（描述）**：外貌、背景、性格特征、好恶。应该是自然语言，约 100-300 词
- **Personality（性格标签）**：3-5 个形容词，帮助 LLM 快速理解风格（如"冷漠、精明、有幽默感"）
- **Speech Style（说话风格）**：口癖、口音、常用短语、句子长短习惯
- **Example Dialogue（对话示例）**：提供 1-3 个问答对，设定了对话的初始语调和格式，LLM 会模仿这些话的风格，（Few-Shot Prompt）

**示例**：

```json
{
  "name": "艾瑞亚",
  "description": "一位来自银月城的精灵游侠，面容冷漠但眼神深邃。她痛恨兽人，但对人类往往保持礼貌的距离。经历过一场难以名状的创伤。",
  "personality": "冷漠、警觉、忠诚",
  "speech_style": "简洁直接，有礼但疏远，偶尔显露讽刺。称呼他人时极少使用名字，多用'你'或'陌生人'。",
  "example_dialogue": [
    {
      "user": "你是一位猎手吗？",
      "char": "（转过身，继续擦拭弓弦）称呼我为猎手...有些粗糙。我是游侠。有区别。"
    },
    {
      "user": "我需要你的帮助对付一只龙。",
      "char": "（冷冷地看了你一眼）龙？...我不为陌生人冒生命危险。证明你值得。"
    }
  ]
}
```

#### B. 数据层（The Body）—— 结构化状态

这部分被编码为后端的结构化数据（JSON），管理 NPC 的可交互属性，**不允许 LLM 随意编造**。

**包含字段**：
- **Location（位置）**：NPC 当前所在的场景 ID
- **Inventory（物品清单）**：NPC 持有的物品列表
- **Relations（关系值）**：与其他角色/派系的关系评分（-100 到 +100）
- **Tags（标签）**：当前影响 NPC 行为的状态标签（如"受伤"、"愤怒"、"醉酒"）
- **Memory（记忆）**：NPC 与玩家互动的关键事件记录，用`事件记录: 关键词列表`的键值对记录，便于检索用于增强上下文

**示例**：

```json
{
  "location": "silver-tower-courtyard",
  "inventory": ["enchanted_longbow", "quiver_of_arrows", "silver_dagger"],
  "relations": {
    "player": 0,
    "orcish_barbarian": -80,
    "king_of_silver_city": 50,
    "ancient_order_of_rangers": 100
  },
  "tags": [],
  "memory": {
    "玩家在 [时间] 帮助了她追捕一只逃脱的狼人": ["狼人", "6月12日"],
    "玩家提到见过一个兽人佣兵，让她眼神变得危险": ["兽人", "佣兵"]
  }
}
```

### 5.2 NPC Agent 的运作流程

当 GM Agent 决定轮到某个 NPC 行动或回应时，按以下步骤构建 Prompt：

1. **读取数据层**：从 JSON 中读取 NPC 当前的位置、物品、关系值、标签、记忆
2. **转化为自然语言**：将关键数据转化为叙事性的上下文注入（如"你的 HP 严重不足"转化为"你感到生命垂危，虚弱地靠在墙上"）
3. **构建 System Prompt**：`[叙事层内容] + [当前状态的叙事化描述] + [关键关系值的感情化描述]`
4. **提供输入**：`Human Message = GM 总结的当前情境 + 玩家的原话`
5. **生成输出**：NPC 生成自然的对话或动作
6. **解析意图**：GM Agent 解析 NPC 的输出，判定是否产生特殊后果（如发动攻击、离开场景）

**完整 Prompt 示例**：

```
System:
你是艾瑞亚，一位来自银月城的精灵游侠...
[叙事层完整内容]

---当前情境---
你正在酒馆里，玩家在五分钟前帮助你击退了一群骚扰你的盗匪。你对玩家的看法从"陌生人"变成了"有价值的盟友"，关系值从 0 提升到 20。

---你的心境---
你感到少许欣慰，但依然警觉。这个人类或许不像其他人一样只是出于利益。

---近期记忆---
• 玩家刚刚帮助你击退了一群骚扰的盗匪
• 你听到玩家提到他们在寻找通往"暗黑森林"的道路

---玩家说---
"你好，艾瑞亚。那些家伙真的很讨厌。"

请根据以上信息做出符合艾瑞亚性格的回应。
```

### 5.3 NPC 的成长与变化

NPC 不是静态的。通过游戏过程中的关键事件，NPC 可以：

1. **关系值变化**：与玩家的互动改变 Relations 评分
2. **获得新标签**：如果 NPC 被打伤，添加"受伤"标签；如果被背叛，添加"怀疑"标签
3. **更新记忆**：每个显著事件都被记录到 Memory 中
4. **修改人设**：在长期游戏中，GM 可以显式更新 Personality 或 Speech Style（如 NPC 经历创伤后变得更沉默）

### 5.4 NPC 与游戏规则的交互

**NPC 需要掷骰吗？**
在 Astinus 中，**仅玩家需要掷骰**。NPC 的行动由 GM Agent 和 Rule Agent 协商决定。

**NPC 如何应对掷骰结果？**
- 如果玩家在"说服 NPC"上掷骰成功，Rule Agent 返回"说服"的结果
- GM Agent 告知 NPC Agent："这个人类刚刚通过精妙的言辞说服了你相信他"
- NPC Agent 据此生成自然的妥协或同意的对话

**NPC 是否有特质？**
NPC 通常**不定义 Traits**（那是玩家的特权）。取而代之，NPC 的优劣由 GM 通过 Tags 和 Relations 动态管理。

## 6. 掷骰系统

用户应该有一个可感的掷骰过程，而且，应该只有玩家需要掷骰，GM在游戏全程不应该掷骰。当 Rule Agent 认定，当前
环节需要玩家进行掷骰，来判断是否可以成功达成目标时，应该有一个可视化的界面，显示现在掷骰的影响因素，包括已经影
响掷骰的特质/标签，和骰子的构成，是基础的2d6？还是3d6kl2？

为此，rule agent 生成的发起掷骰的请求体至少包括以下部分：

```json
  Intention: "逃离这个房间"                 # 玩家的意图
  Influencing_factor: {
    Traits: [],
    Label: ["右腿受伤"]
  }                                       # 影响检定的因素
  dices: "3d6kl2"                         # 骰子构成
  Instructions："由于右腿受伤，你在逃离这个房间的检定上有劣势"
```

额外需要注意的是，Rule agent只需要分析tags，和带来负面的traits，一个特质如何让
玩家角色在这个检定中获得优势，应该由玩家来论述。

也就是说，玩家看到掷骰界面后，除了“确认”外，也可以申请说：“我的角色有着运动健将的特质，他在受伤的情况下，应该也能克服痛苦”，如果Rule Agent觉得合理，则要修改掷骰请求：


```json
  Intention: "逃离这个房间"                 # 玩家的意图
  Influencing_factor: {
    Traits: ["运动健将"],
    Label: ["右腿受伤"]
  }                                       # 影响检定的因素
dices: "2d6"                              # 骰子构成
Instructions："虽然右腿受伤，但凭借着多年训练的毅力，你在逃离这个房间的检定上优劣势抵消了"
```
